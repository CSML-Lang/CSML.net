#region License
// ====================================================
// Team DOML Copyright(C) 2017 Team DOML
// This program comes with ABSOLUTELY NO WARRANTY; This is free software, 
// and you are welcome to redistribute it under certain conditions; See 
// file LICENSE, which is part of this source code package, for details.
// ====================================================
#endregion

using System;
using System.Collections.Generic;
using DOML.Logger;

namespace DOML.IR {
    // For later expansion?
    using DEC = Decimal;
    using BOOL = Boolean;
    using STR = String;

#if (BYTE_TYPES || SMALL_TYPES || MED_TYPES)
    using FLOAT = Single;
#else
    // To expand if we support 16 bit/128/...
    using FLOAT = Double;
#endif

#if BYTE_TYPES
    using INT = Int8;
#elif SMALL_TYPES
    using INT = Int16;
#elif MED_TYPES
    using INT = Int32;
#else
    using INT = Int64;
#endif

    /// <summary>
    /// Opcodes for DOML IR.
    /// </summary>
    public enum Opcodes : byte {
        #region System
        /// <summary>
        /// `nop(void)`
        /// Explicitly does nothing.
        /// </summary>
        NOP = 0,

        /// <summary>
        /// `init(stackSize: int, registerSize: int)`
        /// Initialises the stack and regsiters.
        /// </summary>
        INIT = 1,

        /// <summary>
        /// `init(void)`
        /// De-initialises the stack and regsiters.
        /// </summary>
        DE_INIT = 2,

        /// <summary>
        /// `create_type(id: int, depth: int, (CollectionID: CollectionTypeID, Type: TypeID)[depth])`
        /// Creates a complex type.
        /// </summary>
        CREATE_TYPE = 3,
        #endregion
        #region STACK
        /// <summary>
        /// `new_obj(object: Type, constructor: Fn, register: int, count: int, parameters: object[count])`
        /// Creates a new object with an applied constructor call.
        /// </summary>
        NEW_OBJ = 10,

        /// <summary>
        /// `push(type: TypeID, count: int, parameters: object[count])`
        /// Pushes a set of objects onto the stack.
        /// </summary>
        PUSH = 11,
        CALL_N = 12,
        CALL_STACK = 13,
        POP = 14,
        GET_N = 15,
        GET_STACK = 16,
        #endregion
        #region QUICK_STACK
        QUICK_PUSH = 20,
        QUICK_CALL = 21,
        P_CALL = 22, // NOT CONFIRMED
        DUMB_GET = 24,
        #endregion
        #region ARRAY
        PUSH_ARRAY = 30,
        SET_ARRAY = 31,
        GET_ARRAY = 32,
        ARRAY_CPY = 33,
        COMPACT = 34,
        #endregion
        #region MAPS
        PUSH_MAP = 40,
        PUSH_COLLECTION = 41,
        SET_MAP = 42,
        SET_COLLECTION = 43,
        QUICK_SET_MAP = 44,
        ZIP_MAP = 45,
        GET_MAP = 46,
        GET_COLLECTION = 47,
        #endregion
    }

    /// <summary>
    /// The interpreter for DOML IR.
    /// This handles executing the opcodes.
    /// </summary>
    public partial class Interpreter {
        /// <summary>
        /// All the instructions to execute.
        /// </summary>
        public readonly List<Instruction> Instructions;

        /// <summary>
        /// The runtime of the interpreter instance.
        /// Manages the stack VM and registers.
        /// </summary>
        public readonly InterpreterRuntime Runtime;

        /// <summary>
        /// Create a new interpreter instance.
        /// </summary>
        /// <param name="instructions"> The instructions to assign to this interpreter instance. </param>
        public Interpreter(List<Instruction> instructions) {
            Instructions = instructions;
            Runtime = new InterpreterRuntime();
        }

        /// <summary>
        /// Executes all instructions.
        /// </summary>
        /// <param name="safe"> Run either safe or unsafe instructions (safe does checks, unsafe doesn't). </param>
        /// <remarks> If using the code generated by the parser instance you can use unsafe else use safe. </remarks>
        public void Execute(bool safe = true) {
            Runtime.ClearSpace();

            for (int i = 0; i < Instructions.Count; i++) {
                if (safe)
                    HandleSafeInstruction(Instructions[i]);
                else
                    HandleUnsafeInstruction(Instructions[i]);
            }
        }

        /// <summary>
        /// Handles the instruction safely.
        /// </summary>
        /// <param name="instruction"> The instruction. </param>
        public void HandleSafeInstruction(Instruction instruction) {
            switch ((Opcodes)instruction.OpCode) {
                #region System Instructions
                case Opcodes.INIT: {
                    INT regValue = (INT)instruction.Parameters[0];
                    break;
                }
                #endregion
                default:
                throw new NotImplementedException("Option not implemented");
            }
        }

        /// <summary>
        /// Handles the instruction unsafely.
        /// </summary>
        /// <param name="instruction"> The instruction. </param>
        public void HandleUnsafeInstruction(Instruction instruction) {
            switch ((Opcodes)instruction.OpCode) {
                #region System Instructions

                #endregion
                default:
                throw new NotImplementedException("Option not implemented");
            }
        }
    }
}
