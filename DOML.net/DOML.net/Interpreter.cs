#region License
// ====================================================
// Team DOML Copyright(C) 2017 Team DOML
// This program comes with ABSOLUTELY NO WARRANTY; This is free software, 
// and you are welcome to redistribute it under certain conditions; See 
// file LICENSE, which is part of this source code package, for details.
// ====================================================
#endregion

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DOML.Logger;

namespace DOML.IR {
    public enum State {
        VEC,
        MAP,
        LITERAL,
        OBJ,
    }

    /// <summary>
    /// Opcodes for DOML IR.
    /// </summary>
    public enum Opcodes : byte {
        #region System
        /// <summary>
        /// `nop(void)`
        /// Explicitly does nothing.
        /// </summary>
        NOP = 0,

        /// <summary>
        /// `init(stackSize: int, registerSize: int)`
        /// Initialises the stack and regsiters.
        /// </summary>
        INIT = 1,

        /// <summary>
        /// `init(void)`
        /// De-initialises the stack and regsiters.
        /// </summary>
        DE_INIT = 2,
        #endregion
        #region STACK
        /// <summary>
        /// `new_obj(object: Type, constructor: Fn, register: int, count: int)`
        /// Creates a new object with an applied constructor call.
        /// </summary>
        NEW_OBJ = 10,

        /// <summary>
        /// `push(type: TypeID, count: int, parameters: object[count])`
        /// Pushes a set of objects onto the stack.
        /// </summary>
        PUSH = 11,
        CALL = 12,
        CALL_STACK = 13,
        POP = 14,
        GET = 15,
        GET_STACK = 16,
        #endregion
        #region QUICK_STACK
        QUICK_PUSH = 20,
        QUICK_CALL = 21,
        P_CALL = 22, // UNCONFIRMED
        P_NEW_OBJ = 23, // UNCONFIRMED
        P_GET = 24,
        QUICK_GET = 25,
        #endregion
        #region COLLECTIONS
        SET_INDEX = 30,
        SET_INDEX_STACK = 31,
        QUICK_SET_INDEX = 32,
        GET_INDEX = 33,
        QUICK_GET_INDEX = 34,
        QUICK_CPY = 35,
        COMPACT = 36,
        #endregion
    }

    /// <summary>
    /// The interpreter for DOML IR.
    /// This handles executing the opcodes.
    /// </summary>
    public class Interpreter {
        /// <summary>
        /// All the instructions to execute.
        /// </summary>
        public readonly List<Instruction> Instructions;

        /// <summary>
        /// The runtime of the interpreter instance.
        /// Manages the stack VM and registers.
        /// </summary>
        public readonly InterpreterRuntime Runtime;

        /// <summary>
        /// Create a new interpreter instance.
        /// </summary>
        /// <param name="instructions"> The instructions to assign to this interpreter instance. </param>
        public Interpreter(List<Instruction> instructions) {
            Instructions = instructions;
            Runtime = new InterpreterRuntime();
        }

        /// <summary>
        /// Executes all instructions.
        /// </summary>
        /// <param name="safe"> Run either safe or unsafe instructions (safe does checks, unsafe doesn't). </param>
        /// <remarks> If using the code generated by the parser instance you can use unsafe else use safe. </remarks>
        public void Execute(bool safe) {
            Runtime.ClearSpace();

            for (int i = 0; i < Instructions.Count; i++) {
                if (safe) {
                    HandleSafeInstruction(Instructions[i]);
                } else {
                    HandleUnsafeInstruction(Instructions[i]);
                }
            }
        }

        private void ParameterHelper<T1>(Instruction instruction, out T1 t1) {
            t1 = (T1)instruction.Parameters[0];
        }

        private void ParameterHelper<T1, T2>(Instruction instruction, out T1 t1, out T2 t2) {
            t1 = (T1)instruction.Parameters[0];
            t2 = (T2)instruction.Parameters[1];
        }

        private void ParameterHelper<T1, T2, T3>(Instruction instruction, out T1 t1, out T2 t2, out T3 t3) {
            t1 = (T1)instruction.Parameters[0];
            t2 = (T2)instruction.Parameters[1];
            t3 = (T3)instruction.Parameters[2];
        }

        public static Type GetTypeForParamType(ParamType type) {
            switch (type) {
            case ParamType.INT: return typeof(long);
            case ParamType.FLT: return typeof(double);
            case ParamType.DEC: return typeof(decimal);
            case ParamType.STR: return typeof(string);
            case ParamType.BOOL: return typeof(bool);
            case ParamType.OBJ: return typeof(object);
            case ParamType.MAP:
            case ParamType.VEC:
            throw new InvalidOperationException("Internal Error: GetTypeForParamType shouldn't be called for Maps/Vectors");
            default:
            throw new NotImplementedException();
            }
        }

        public static Type CreateType(IEnumerator types, ref int len) {
            // Work back to front
            types.MoveNext();
            len++;
            if ((ParamType)types.Current == ParamType.VEC) {
                return CreateType(types, ref len).MakeArrayType();
            } else if ((ParamType)types.Current == ParamType.MAP) {
                Type keyType = CreateType(types, ref len);
                Type valueType = CreateType(types, ref len);
                return typeof(Dictionary<,>).MakeGenericType(keyType, valueType);
            } else {
                return GetTypeForParamType((ParamType)types.Current);
            }
        }

        /// <summary>
        /// Handles the instruction safely.
        /// </summary>
        /// <param name="instruction"> The instruction. </param>
        public void HandleSafeInstruction(Instruction instruction) {
            switch ((Opcodes)instruction.OpCode) {
            #region System Instructions
            case Opcodes.NOP: break;
            case Opcodes.INIT: {
                ParameterHelper(instruction, out int stackSize, out int regSize);
                Runtime.ReserveRegister(regSize);
                Runtime.ReserveSpace(stackSize);
                break;
            }
            case Opcodes.DE_INIT:
            Runtime.ClearRegisters();
            Runtime.ClearSpace();
            break;
            #endregion
            #region Push Instructions
            case Opcodes.NEW_OBJ: {
                ParameterHelper(instruction, out int register, out FunctionDefinition constructor);
                constructor.action(Runtime, register);
                break;
            }
            case Opcodes.PUSH: {
                int len = 0;
                Type type = CreateType(instruction.Parameters.GetEnumerator(), ref len);
                if (type.IsArray) {
                    // Handle Array
                    if (len != instruction.Parameters.Length - 1 || !Runtime.Push(Array.CreateInstance(type, (int)instruction.Parameters[len]), true)) {
                        Log.Error("Invalid Push Array");
                        return;
                    }
                } else if (type.IsConstructedGenericType) {
                    // Is Map
                    if (!Runtime.Push(Activator.CreateInstance(type), true)) {
                        Log.Error("Invalid Push Map");
                        return;
                    }
                } else {
                    // Standard push
                    // @FIXME: single check (in terms of required size)
                    for (int i = 1; i < instruction.Parameters.Length; i++) {
                        if (!Runtime.Push(instruction.Parameters[i], true)) {
                            Log.Error("Invalid Push Value");
                            return;
                        }
                    }
                }
                break;
            }
            case Opcodes.CALL: {
                ParameterHelper(instruction, out FunctionDefinition callee, out int register);
                callee.action(Runtime, register);
                break;
            }
            case Opcodes.CALL_STACK: {
                if (!Runtime.Pop(out object callee)) {
                    Log.Error("Invalid call n");
                    return;
                }
                Runtime.SetObject(callee, -1);
                Action<InterpreterRuntime, int> action = ((FunctionDefinition)instruction.Parameters[0]).action;
                action(Runtime, -1);
                Runtime.Push(callee, true);
                break;
            }
            case Opcodes.POP: {
                ParameterHelper(instruction, out int count);
                for (int i = 0; i < count; i++) {
                    if (!Runtime.Pop()) {
                        Log.Error("Invalid Pop");
                    }
                }
                break;
            }
            case Opcodes.GET: {
                ParameterHelper(instruction, out int register, out FunctionDefinition func);
                func.action(Runtime, register);
                break;
            }
            case Opcodes.GET_STACK: {
                if (!Runtime.Pop(out object callee)) {
                    Log.Error("Invalid call n");
                    return;
                }
                Runtime.SetObject(callee, -1);
                Action<InterpreterRuntime, int> action = ((FunctionDefinition)instruction.Parameters[0]).action;
                action(Runtime, -1);
                Runtime.Push(callee, true);
                break;
            }
            #endregion
            #region Quick Instructions
            case Opcodes.QUICK_PUSH:
            case Opcodes.QUICK_CALL:
            case Opcodes.P_CALL:
            case Opcodes.P_NEW_OBJ:
            case Opcodes.QUICK_GET:
            throw new NotImplementedException();
            #endregion
            #region Collections
            case Opcodes.SET_INDEX: {
                ParameterHelper(instruction, out State state);
                if (state == State.MAP) {
                    object value = instruction.Parameters[instruction.Parameters.Length-1];
                    if (!Runtime.Pop(out IDictionary result)) {
                        Log.Error("Invalid set map");
                        return;
                    }

                    for (int i = 1; i < instruction.Parameters.Length - 2; i++) {
                        result = (IDictionary)result[instruction.Parameters[i]];
                    }
                    result[instruction.Parameters[instruction.Parameters.Length - 2]] = value;
                } else if (state == State.VEC) {
                    if (!Runtime.Peek(out Array array)) {
                        Log.Error("Invalid set array");
                        return;
                    }

                    int lastIndex = instruction.Parameters.Length - 1;
                    array.SetValue(instruction.Parameters[lastIndex], instruction.Parameters.Skip(1).Take(lastIndex).Cast<int>().ToArray());
                } else {
                    Log.Error("SetIndex only valid on collections");
                    return;
                }
                break;
            }
            case Opcodes.QUICK_SET_INDEX:
            case Opcodes.SET_INDEX_STACK:
            throw new NotImplementedException();
            case Opcodes.GET_INDEX: {
                ParameterHelper(instruction, out State state);
                if (state == State.MAP) {
                    if (!Runtime.Pop(out IDictionary result)) {
                        Log.Error("Invalid Get Map");
                        return;
                    }
                    for (int i = 0; i < instruction.Parameters.Length - 2; i++) {
                        result = (IDictionary)result[instruction.Parameters[i]];
                    }
                    if (!Runtime.Push(result[instruction.Parameters[instruction.Parameters.Length - 2]], true)) {
                        Log.Error("Invalid Get Map");
                    }
                } else if (state == State.VEC) {
                    if (!Runtime.Peek(out Array array) || !Runtime.Push(array.GetValue(instruction.Parameters.Cast<int>().ToArray()), true)) {
                        Log.Error("Invalid get array");
                        return;
                    }
                } else {
                    Log.Error("SetIndex only valid on collections");
                    return;
                }
                break;
            }
            case Opcodes.QUICK_CPY: {
                ParameterHelper(instruction, out State state);
                if (state == State.MAP) {
                    throw new NotImplementedException("QuickCpy not implemented for maps");
                } else if (state == State.VEC) {
                    if (!Runtime.Pop(out Array array)) {
                        Log.Error("Invalid set array");
                        return;
                    }
                    // Maybe we can't always do this?
                    instruction.Parameters.CopyTo(array, 1);
                } else {
                    Log.Error("SetIndex only valid on collections");
                    return;
                }
                break;
            }
            case Opcodes.COMPACT: {
                // @TODO
                throw new NotImplementedException("Compact not implemented");
            }
            #endregion
            default:
            throw new NotImplementedException("Option not implemented");
            }
        }

        /// <summary>
        /// Handles the instruction unsafely.
        /// </summary>
        /// <param name="instruction"> The instruction. </param>
        public void HandleUnsafeInstruction(Instruction instruction) {
            switch ((Opcodes)instruction.OpCode) {
            #region System Instructions

            #endregion
            default:
            throw new NotImplementedException("Option not implemented");
            }
        }
    }
}
