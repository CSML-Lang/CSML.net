#region License
// ====================================================
// Team DOML Copyright(C) 2017 Team DOML
// This program comes with ABSOLUTELY NO WARRANTY; This is free software, 
// and you are welcome to redistribute it under certain conditions; See 
// file LICENSE, which is part of this source code package, for details.
// ====================================================
#endregion

using System;
using System.Collections.Generic;
using DOML.Logger;

namespace DOML.IR {
    /// <summary>
    /// Opcodes for DOML IR.
    /// </summary>
    public enum Opcodes : byte {
        #region System
        /// <summary>
        /// `nop(void)`
        /// Explicitly does nothing.
        /// </summary>
        NOP = 0,

        /// <summary>
        /// `init(stackSize: int, registerSize: int)`
        /// Initialises the stack and regsiters.
        /// </summary>
        INIT = 1,

        /// <summary>
        /// `init(void)`
        /// De-initialises the stack and regsiters.
        /// </summary>
        DE_INIT = 2,

        /// <summary>
        /// `create_type(id: int, depth: int, (CollectionID: CollectionTypeID, Type: TypeID)[depth])`
        /// Creates a complex type.
        /// </summary>
        CREATE_TYPE = 3,
        #endregion
        #region STACK
        /// <summary>
        /// `new_obj(object: Type, constructor: Fn, register: int, count: int)`
        /// Creates a new object with an applied constructor call.
        /// </summary>
        NEW_OBJ = 10,

        /// <summary>
        /// `push(type: TypeID, count: int, parameters: object[count])`
        /// Pushes a set of objects onto the stack.
        /// </summary>
        PUSH = 11,
        CALL_N = 12,
        CALL_STACK = 13,
        POP = 14,
        GET_N = 15,
        GET_STACK = 16,
        #endregion
        #region QUICK_STACK
        QUICK_PUSH = 20,
        QUICK_CALL = 21,
        P_CALL = 22, // UNCONFIRMED
        P_NEW_OBJ = 23, // UNCONFIRMED
        QUICK_GET = 24,
        DUMB_GET = 25,
        #endregion
        #region ARRAY
        PUSH_ARRAY = 30,
        SET_ARRAY = 31,
        GET_ARRAY = 32,
        ARRAY_CPY = 33,
        COMPACT = 34,
        #endregion
        #region MAPS
        PUSH_MAP = 40,
        PUSH_COLLECTION = 41,
        SET_MAP = 42,
        SET_COLLECTION = 43,
        QUICK_SET_MAP = 44,
        ZIP_MAP = 45,
        GET_MAP = 46,
        GET_COLLECTION = 47,
        #endregion
    }

    /// <summary>
    /// The interpreter for DOML IR.
    /// This handles executing the opcodes.
    /// </summary>
    public class Interpreter {
        /// <summary>
        /// All the instructions to execute.
        /// </summary>
        public readonly List<Instruction> Instructions;

        /// <summary>
        /// The runtime of the interpreter instance.
        /// Manages the stack VM and registers.
        /// </summary>
        public readonly InterpreterRuntime Runtime;

        /// <summary>
        /// Create a new interpreter instance.
        /// </summary>
        /// <param name="instructions"> The instructions to assign to this interpreter instance. </param>
        public Interpreter(List<Instruction> instructions) {
            Instructions = instructions;
            Runtime = new InterpreterRuntime();
        }

        /// <summary>
        /// Executes all instructions.
        /// </summary>
        /// <param name="safe"> Run either safe or unsafe instructions (safe does checks, unsafe doesn't). </param>
        /// <remarks> If using the code generated by the parser instance you can use unsafe else use safe. </remarks>
        public void Execute(bool safe = true) {
            Runtime.ClearSpace();

            for (int i = 0; i < Instructions.Count; i++) {
                if (safe) {
                    HandleSafeInstruction(Instructions[i]);
                } else {
                    HandleUnsafeInstruction(Instructions[i]);
                }
            }
        }

        /// <summary>
        /// Handles the instruction safely.
        /// </summary>
        /// <param name="instruction"> The instruction. </param>
        public void HandleSafeInstruction(Instruction instruction) {
            switch ((Opcodes)instruction.OpCode) {
                #region System Instructions
                case Opcodes.NOP:
                    break;
                case Opcodes.INIT: {
                        int stackSize = (int)instruction.Parameters[0];
                        int regSize = (int)instruction.Parameters[1];
                        Runtime.ReserveRegister(regSize);
                        Runtime.ReserveSpace(stackSize);
                        break;
                    }
                case Opcodes.DE_INIT:
                    Runtime.ClearRegisters();
                    Runtime.ClearSpace();
                    break;
                case Opcodes.CREATE_TYPE:
                    // @TODO: Support complex types
                    throw new NotImplementedException();
                    break;
                #endregion
                #region Push Instructions
                case Opcodes.NEW_OBJ: {
                        string type = (string)instruction.Parameters[0];
                        string constructor = (string)instruction.Parameters[1];
                        int register = (int)instruction.Parameters[2];
                        // @TODO: Possibly not needed?
                        int count = (int)instruction.Parameters[3];
                        if (Runtime.CurrentStackSize < count) {
                            Log.Error("Invalid Stack Size");
                            return;
                        }


                        break;
                    }
                case Opcodes.PUSH:
                    break;
                case Opcodes.CALL_N:
                    break;
                case Opcodes.CALL_STACK:
                    break;
                case Opcodes.POP:
                    break;
                case Opcodes.GET_N:
                    break;
                case Opcodes.GET_STACK:
                    break;
                #endregion
                #region Quick Instructions
                case Opcodes.QUICK_PUSH:
                    break;
                case Opcodes.QUICK_CALL:
                    break;
                case Opcodes.P_CALL:
                    break;
                case Opcodes.P_NEW_OBJ:
                    break;
                case Opcodes.QUICK_GET:
                    break;
                case Opcodes.DUMB_GET:
                    break;
                #endregion
                #region Array Instructions
                case Opcodes.PUSH_ARRAY:
                    break;
                case Opcodes.SET_ARRAY:
                    break;
                case Opcodes.GET_ARRAY:
                    break;
                case Opcodes.ARRAY_CPY:
                    break;
                case Opcodes.COMPACT:
                    break;
                #endregion
                #region Map Instructions
                case Opcodes.PUSH_MAP:
                    break;
                case Opcodes.PUSH_COLLECTION:
                    break;
                case Opcodes.SET_MAP:
                    break;
                case Opcodes.SET_COLLECTION:
                    break;
                case Opcodes.QUICK_SET_MAP:
                    break;
                case Opcodes.ZIP_MAP:
                    break;
                case Opcodes.GET_MAP:
                    break;
                case Opcodes.GET_COLLECTION:
                    break;
                #endregion
                default:
                    throw new NotImplementedException("Option not implemented");
            }
        }

        /// <summary>
        /// Handles the instruction unsafely.
        /// </summary>
        /// <param name="instruction"> The instruction. </param>
        public void HandleUnsafeInstruction(Instruction instruction) {
            switch ((Opcodes)instruction.OpCode) {
                #region System Instructions

                #endregion
                default:
                    throw new NotImplementedException("Option not implemented");
            }
        }
    }
}
